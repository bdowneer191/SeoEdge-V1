import { NextResponse } from 'next/server';
import { initializeFirebaseAdmin } from '@/lib/firebaseConfig';

export const dynamic = 'force-dynamic';

function getOriginalUrlFromPageDoc(doc: any): string {
  const data = doc.data();
  return data?.originalUrl || data?.url || doc.id.replace(/__/g, '/');
}

/**
 * Enhanced dashboard stats API that provides comprehensive site analytics
 */
export async function GET() {
  try {
    const firestore = initializeFirebaseAdmin();

    console.log('[Dashboard API] Fetching comprehensive dashboard data...');

    // 1. Get dashboard stats (generated by cron job)
    const dashboardStatsDoc = await firestore.collection('dashboard_stats').doc('latest').get();

    let dashboardStats = null;
    if (dashboardStatsDoc.exists) {
      dashboardStats = dashboardStatsDoc.data();
      console.log('[Dashboard API] Dashboard stats found:', dashboardStats?.status);
    } else {
      console.log('[Dashboard API] No dashboard stats found - cron job may not have run yet');
    }

    // 2. Get tiering stats for performance overview
    const tieringStatsDoc = await firestore.collection('tiering_stats').doc('latest').get();

    let tieringStats = null;
    if (tieringStatsDoc.exists) {
      tieringStats = tieringStatsDoc.data();
      console.log('[Dashboard API] Tiering stats found with', tieringStats?.totalPagesProcessed, 'pages');
    }

    // 3. Get recent high-performing and declining pages
    const [winningPagesSnapshot, losingPagesSnapshot] = await Promise.all([
      firestore.collection('pages')
        .where('performance_tier', 'in', ['Champions', 'Rising Stars', 'Cash Cows'])
        .orderBy('performance_score', 'desc')
        .limit(10)
        .get(),
      firestore.collection('pages')
        .where('performance_tier', 'in', ['Declining', 'At Risk', 'Problem Pages'])
        .orderBy('performance_score', 'asc')
        .limit(10)
        .get()
    ]);

    // Process winning pages
    const winningPages = winningPagesSnapshot.docs.map(doc => {
      const data = doc.data();
      const originalUrl = getOriginalUrlFromPageDoc(doc);

      return {
        url: originalUrl,
        title: data.title || `Page: ${originalUrl.split('/').pop() || 'Untitled'}`,
        tier: data.performance_tier || 'Unknown',
        score: data.performance_score || 0,
        clicks: data.metrics?.recent?.totalClicks || 0,
        impressions: data.metrics?.recent?.totalImpressions || 0,
        ctr: data.metrics?.recent?.averageCtr || 0,
        change: data.metrics?.change?.clicks || 0,
        reasoning: data.performance_reasoning || 'No analysis available'
      };
    });

    // Process losing pages
    const losingPages = losingPagesSnapshot.docs.map(doc => {
      const data = doc.data();
      const originalUrl = getOriginalUrlFromPageDoc(doc);

      return {
        url: originalUrl,
        title: data.title || `Page: ${originalUrl.split('/').pop() || 'Untitled'}`,
        tier: data.performance_tier || 'Unknown',
        score: data.performance_score || 0,
        clicks: data.metrics?.recent?.totalClicks || 0,
        impressions: data.metrics?.recent?.totalImpressions || 0,
        ctr: data.metrics?.recent?.averageCtr || 0,
        change: data.metrics?.change?.clicks || 0,
        reasoning: data.performance_reasoning || 'No analysis available',
        // Additional fields for losing pages
        impressionChange: data.metrics?.change?.impressions || 0,
        impressions1: data.metrics?.recent?.totalImpressions || 0,
        impressions2: data.metrics?.baseline?.totalImpressions || 0
      };
    });

    // 4. Generate site summary
    const siteSummary = {
      dashboardStats: dashboardStats || {
        status: 'pending',
        message: 'Analytics data is being processed. Please run the daily stats cron job.',
        metrics: {
          totalClicks: { current: 0, trend: null },
          totalImpressions: { current: 0, trend: null },
          averageCtr: { current: 0, trend: null },
          averagePosition: { current: 0, trend: null }
        }
      },
      performanceOverview: tieringStats ? {
        totalPages: tieringStats.totalPagesProcessed || 0,
        distribution: tieringStats.tierDistribution || {},
        lastAnalysis: tieringStats.lastRun || new Date().toISOString(),
        topPerformers: winningPages.length,
        needsAttention: losingPages.length
      } : {
        totalPages: 0,
        distribution: { 'New/Low Data': 0 },
        lastAnalysis: new Date().toISOString(),
        topPerformers: 0,
        needsAttention: 0,
        message: 'Performance analysis pending - run the daily stats cron job'
      }
    };

    // 5. Check if we have any meaningful data
    const hasBasicData = dashboardStats && dashboardStats.status === 'success';
    const hasPerformanceData = tieringStats && tieringStats.totalPagesProcessed > 0;

    if (!hasBasicData && !hasPerformanceData) {
      return NextResponse.json({
        siteSummary: {
          dashboardStats: {
            status: 'no_data',
            message: 'No analytics data available. Please run the GSC ingestion and daily stats cron jobs.',
            lastUpdated: new Date().toISOString()
          }
        },
        winningPages: [],
        losingPages: [],
        error: 'No analytics data available',
        hint: 'Run the GSC ingestion cron job first, then the daily stats cron job to populate the dashboard.'
      });
    }

    const result = {
      siteSummary,
      winningPages,
      losingPages,
      dataFreshness: {
        dashboardStats: dashboardStats?.lastUpdated || null,
        performanceAnalysis: tieringStats?.lastRun || null,
        pagesAnalyzed: tieringStats?.totalPagesProcessed || 0
      },
      recommendations: []
    };

    // Add contextual recommendations
    if (!hasBasicData) {
      result.recommendations.push({
        type: 'setup',
        priority: 'high',
        action: 'Run daily stats cron job to generate analytics insights',
        impact: 'Enable comprehensive performance tracking'
      });
    }

    if (!hasPerformanceData) {
      result.recommendations.push({
        type: 'setup',
        priority: 'high',
        action: 'Run performance tiering analysis to categorize pages',
        impact: 'Identify optimization opportunities'
      });
    }

    if (losingPages.length > winningPages.length) {
      result.recommendations.push({
        type: 'optimization',
        priority: 'medium',
        action: 'Focus on declining pages - investigate causes and implement fixes',
        impact: 'Recover lost traffic and prevent further decline'
      });
    }

    console.log(`[Dashboard API] Successfully prepared dashboard with ${winningPages.length} winning and ${losingPages.length} losing pages`);

    return NextResponse.json(result);

  } catch (error) {
    console.error('[Dashboard API] Error fetching dashboard data:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';

    return NextResponse.json({
      siteSummary: {
        dashboardStats: {
          status: 'error',
          message: `Dashboard error: ${errorMessage}`,
          lastUpdated: new Date().toISOString()
        }
      },
      winningPages: [],
      losingPages: [],
      error: errorMessage,
      hint: 'Check the server logs and ensure all cron jobs are configured correctly.'
    }, { status: 200 }); // Return 200 so the frontend can handle gracefully
  }
}
